from PIL import Image
import numpy as np
import cv2
import os

def is_image_file(filename):
    return any(filename.endswith(extension) for extension in [".png", ".jpg", ".bmp", ".JPG", ".jpeg", ".npy", ".tiff", ".tif", ".webp", ".JPEG", ".PNG", ".BMP", ".TIFF", ".TIF", ".WEBP"])

def load_img(filepath):
    """
    > Generated by Claude Sonnet4
    Load image from various formats and return PIL RGB image
    
    Args:
        filepath: path to image file
        
    Returns:
        PIL Image in RGB format (same as original function), HWC
    """
    if not os.path.exists(filepath):
        raise FileNotFoundError(f"Image file not found: {filepath}")
    
    file_ext = os.path.splitext(filepath)[1].lower()
    
    try:
        if file_ext == '.npy':
            # Handle numpy array files
            img_array = np.load(filepath)
            
            # Convert to uint8 if needed
            if img_array.dtype != np.uint8:
                if img_array.max() <= 1.0:
                    # Assume normalized [0, 1]
                    img_array = (img_array * 255).astype(np.uint8)
                else:
                    # Assume already in [0, 255] range
                    img_array = np.clip(img_array, 0, 255).astype(np.uint8)
            
            # Handle different array shapes
            if len(img_array.shape) == 2:
                # Grayscale
                img = Image.fromarray(img_array, mode='L').convert('RGB')
            elif len(img_array.shape) == 3:
                if img_array.shape[2] == 1:
                    # Grayscale with channel dimension
                    img = Image.fromarray(img_array.squeeze(), mode='L').convert('RGB')
                elif img_array.shape[2] == 3:
                    # RGB
                    img = Image.fromarray(img_array, mode='RGB')
                elif img_array.shape[2] == 4:
                    # RGBA
                    img = Image.fromarray(img_array, mode='RGBA').convert('RGB')
                else:
                    raise ValueError(f"Unsupported number of channels: {img_array.shape[2]}")
            else:
                raise ValueError(f"Unsupported array shape: {img_array.shape}")
                
        elif file_ext in ['.tiff', '.tif']:
            # Handle TIFF files which might have issues with PIL
            try:
                img = Image.open(filepath).convert('RGB')
            except Exception:
                # Fallback to OpenCV for problematic TIFF files
                img_array = cv2.imread(filepath, cv2.IMREAD_COLOR)
                if img_array is None:
                    raise ValueError(f"Failed to load TIFF file: {filepath}")
                img_array = cv2.cvtColor(img_array, cv2.COLOR_BGR2RGB)
                img = Image.fromarray(img_array)
                
        else:
            # Handle all other image formats with PIL
            img = Image.open(filepath)
            
            # Convert to RGB (handles grayscale, RGBA, CMYK, etc.)
            if img.mode != 'RGB':
                img = img.convert('RGB')
    
    except Exception as e:
        # Fallback to OpenCV for any PIL failures
        try:
            img_array = cv2.imread(filepath, cv2.IMREAD_COLOR)
            if img_array is None:
                raise ValueError(f"Failed to load image with both PIL and OpenCV: {filepath}")
            img_array = cv2.cvtColor(img_array, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(img_array)
        except Exception as fallback_e:
            raise ValueError(f"Failed to load image {filepath}. PIL error: {e}, OpenCV error: {fallback_e}")
    
    return img